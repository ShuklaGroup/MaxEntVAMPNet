"""
FileHandler class provides convenience functions to handle collections of trajectory files generated by
AdaptiveSampling runs.
"""
import os
import mdtraj as md


class FileHandler:

    def __init__(self, root, basename="", save_format=""):
        self.root = root if root else os.getcwd()  # Root directory
        self.basename = basename  # Basename for files
        self.subdirs = []  # List of subdirectories where trajectories will be stored
        self.files = {}  # List of files inside subdirectory
        self.n_frames = {}  # Number of frames in a trajectory
        self.init_states = {}  # The initial state file for each trajectory file
        self.save_format = save_format

    def generate_new_round(self, init_states, n_repeats, n_steps, n_round, save_rate, add_basename=""):
        path = os.path.join(self.root, "round_" + str(n_round))
        os.makedirs(path, exist_ok=True)

        self.subdirs.append(path)
        self.files[path] = []

        for i, state in enumerate(init_states):
            for j in range(n_repeats):
                fname = self.basename + \
                        add_basename + \
                        "_traj_{}".format(i) + \
                        "_repeat_{}".format(j) + \
                        self.save_format
                fname = os.path.join(path, fname)
                self.files[path].append(fname)
                self.n_frames[fname] = n_steps // save_rate
                self.init_states[fname] = state

        return self.files[path]

    def list_all_files(self):
        filenames = []
        for subdir in self.subdirs:
            for fname in self.files[subdir]:
                filenames.append(os.path.join(self.root, subdir, fname))

        return filenames

    def check_files(self, top_file=None):
        """
        Check that all files were created as intended. This function does not check the content of the files.
        """
        all_files = self.list_all_files()

        # Check if file exists
        for fname in all_files:
            try:
                assert (os.path.exists(fname))
            except AssertionError as err:
                print("File {} should exist but was not found".format(fname))
                raise err

        # Check if number of frames is correct
        if top_file:
            for fname in all_files:
                traj = md.load(fname, top=top_file)
                try:
                    assert (traj.n_frames == self.n_frames[fname])
                except AssertionError as err:
                    print("File {} contains {} frames but {} were expected".format(fname,
                                                                                   traj.n_frames,
                                                                                   self.n_frames[fname]))
                    raise err

    def find_state_info(self, indices, traj_list, top_file):
        """
        For each datum's index return the tuple (fname, frame_idx, top_file).
        This function maps data points in CV space to the corresponding trajectory conformations.
        """
        all_files = traj_list
        states = []
        for idx in indices:
            counter = 0
            for fname in all_files:
                counter += self.n_frames[fname]
                if (counter - 1) >= idx:
                    frame_idx = idx - (counter - self.n_frames[fname])
                    state = {'fname': fname, 'frame_idx': frame_idx, 'top_file': top_file}
                    states.append(state)
                    break
        # Make sure all indices correspond to a trajectory frame
        assert (len(indices) == len(states))

        return states


class FileHandlerMultiagent(FileHandler):

    def __init__(self, root, n_agents, basename="", save_format=""):
        FileHandler.__init__(self, root, basename=basename, save_format=save_format)
        self.n_agents = n_agents
        self.agent_trajs = [[] for _ in range(n_agents)]  # Save the paths to the trajectories belonging to each agent

    def generate_new_round(self, init_states, n_repeats, n_steps, n_round, save_rate, add_basename=""):
        path = os.path.join(self.root, "round_" + str(n_round))
        os.makedirs(path, exist_ok=True)

        self.subdirs.append(path)
        self.files[path] = []

        for i, state in enumerate(init_states):
            agent_idx = state["agent_idx"]
            for j in range(n_repeats):
                fname = self.basename + \
                        add_basename + \
                        "_agent_{}".format(agent_idx) + \
                        "_traj_{}".format(i) + \
                        "_repeat_{}".format(j) + \
                        self.save_format
                fname = os.path.join(path, fname)
                self.files[path].append(fname)
                self.n_frames[fname] = n_steps // save_rate
                self.init_states[fname] = state
                self.agent_trajs[agent_idx].append(fname)

        return self.files[path]

    def list_agent_files(self, agent_idx):
        return self.agent_trajs[agent_idx]

    def list_all_files(self):
        filenames = []
        for agent_idx in range(self.n_agents):
            for fname in self.agent_trajs[agent_idx]:
                filenames.append(fname)

        return filenames

    def find_state_info(self, indices, traj_list, top_file, executors):
        """
        For each datum's index return the tuple (fname, frame_idx, top_file).
        This function maps data points in CV space to the corresponding trajectory conformations.
        """
        all_files = traj_list
        states = []
        for i, idx in enumerate(indices):
            counter = 0
            executor = executors[i]
            for fname in all_files:
                counter += self.n_frames[fname]
                if (counter - 1) >= idx:
                    frame_idx = idx - (counter - self.n_frames[fname])
                    state = {'fname': fname, 'frame_idx': frame_idx, 'top_file': top_file, 'agent_idx': executor}
                    states.append(state)
                    break
        # Make sure all indices correspond to a trajectory frame
        assert (len(indices) == len(states))

        return states
